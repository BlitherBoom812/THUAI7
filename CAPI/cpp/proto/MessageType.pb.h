// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageType.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>   // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MessageType_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal
{
    class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MessageType_2eproto
{
    static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MessageType_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace protobuf
{

    enum PlaceType : int
    {
        NULL_PLACE_TYPE = 0,
        HOME = 1,
        SPACE = 2,
        RUIN = 3,
        SHADOW = 4,
        ASTEROID = 5,
        RESOURCE = 6,
        BUILDING = 7,
        PlaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        PlaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool PlaceType_IsValid(int value);
    constexpr PlaceType PlaceType_MIN = NULL_PLACE_TYPE;
    constexpr PlaceType PlaceType_MAX = BUILDING;
    constexpr int PlaceType_ARRAYSIZE = PlaceType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceType_descriptor();
    template<typename T>
    inline const std::string& PlaceType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PlaceType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PlaceType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            PlaceType_descriptor(), enum_t_value
        );
    }
    inline bool PlaceType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceType>(
            PlaceType_descriptor(), name, value
        );
    }
    enum CollectorType : int
    {
        NULL_COLLECTOR_TYPE = 0,
        BASIC_COLLECTOR = 1,
        ADVANCED_COLLECTOR = 2,
        ULTIMATE_COLLECTOR = 3,
        CollectorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        CollectorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool CollectorType_IsValid(int value);
    constexpr CollectorType CollectorType_MIN = NULL_COLLECTOR_TYPE;
    constexpr CollectorType CollectorType_MAX = ULTIMATE_COLLECTOR;
    constexpr int CollectorType_ARRAYSIZE = CollectorType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectorType_descriptor();
    template<typename T>
    inline const std::string& CollectorType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, CollectorType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CollectorType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            CollectorType_descriptor(), enum_t_value
        );
    }
    inline bool CollectorType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectorType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectorType>(
            CollectorType_descriptor(), name, value
        );
    }
    enum ArmorType : int
    {
        NULL_ARMOR_TYPE = 0,
        BASIC_ARMOR = 1,
        ADVANCED_ARMOR = 2,
        ULTIMATE_ARMOR = 3,
        ArmorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ArmorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ArmorType_IsValid(int value);
    constexpr ArmorType ArmorType_MIN = NULL_ARMOR_TYPE;
    constexpr ArmorType ArmorType_MAX = ULTIMATE_ARMOR;
    constexpr int ArmorType_ARRAYSIZE = ArmorType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ArmorType_descriptor();
    template<typename T>
    inline const std::string& ArmorType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ArmorType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ArmorType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ArmorType_descriptor(), enum_t_value
        );
    }
    inline bool ArmorType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ArmorType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ArmorType>(
            ArmorType_descriptor(), name, value
        );
    }
    enum ShieldType : int
    {
        NULL_SHIELD_TYPE = 0,
        BASIC_SHIELD = 1,
        ADVANCED_SHIELD = 2,
        ULTIMATE_SHIELD = 3,
        ShieldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ShieldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ShieldType_IsValid(int value);
    constexpr ShieldType ShieldType_MIN = NULL_SHIELD_TYPE;
    constexpr ShieldType ShieldType_MAX = ULTIMATE_SHIELD;
    constexpr int ShieldType_ARRAYSIZE = ShieldType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShieldType_descriptor();
    template<typename T>
    inline const std::string& ShieldType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ShieldType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ShieldType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ShieldType_descriptor(), enum_t_value
        );
    }
    inline bool ShieldType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShieldType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShieldType>(
            ShieldType_descriptor(), name, value
        );
    }
    enum BuilderType : int
    {
        NULL_BUILDER_TYPE = 0,
        BASIC_BUILDER = 1,
        ADVANCED_BUILDER = 2,
        ULTIMATE_BUILDER = 3,
        BuilderType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        BuilderType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool BuilderType_IsValid(int value);
    constexpr BuilderType BuilderType_MIN = NULL_BUILDER_TYPE;
    constexpr BuilderType BuilderType_MAX = ULTIMATE_BUILDER;
    constexpr int BuilderType_ARRAYSIZE = BuilderType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BuilderType_descriptor();
    template<typename T>
    inline const std::string& BuilderType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, BuilderType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function BuilderType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            BuilderType_descriptor(), enum_t_value
        );
    }
    inline bool BuilderType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuilderType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BuilderType>(
            BuilderType_descriptor(), name, value
        );
    }
    enum BulletType : int
    {
        NULL_BULLET_TYPE = 0,
        LASER = 1,
        PLASMA = 2,
        SHELL = 3,
        MISSILE = 4,
        ELECTRIC_ARC = 5,
        BulletType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        BulletType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool BulletType_IsValid(int value);
    constexpr BulletType BulletType_MIN = NULL_BULLET_TYPE;
    constexpr BulletType BulletType_MAX = ELECTRIC_ARC;
    constexpr int BulletType_ARRAYSIZE = BulletType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BulletType_descriptor();
    template<typename T>
    inline const std::string& BulletType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, BulletType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function BulletType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            BulletType_descriptor(), enum_t_value
        );
    }
    inline bool BulletType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BulletType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BulletType>(
            BulletType_descriptor(), name, value
        );
    }
    enum ShipState : int
    {
        NULL_STATUS = 0,
        IDLE = 1,
        PRODUCING = 2,
        CONSTRUCTING = 3,
        RECOVERING = 4,
        RECYCLING = 5,
        ATTACKING = 6,
        SWINGING = 7,
        STUNNED = 8,
        ShipState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ShipState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ShipState_IsValid(int value);
    constexpr ShipState ShipState_MIN = NULL_STATUS;
    constexpr ShipState ShipState_MAX = STUNNED;
    constexpr int ShipState_ARRAYSIZE = ShipState_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShipState_descriptor();
    template<typename T>
    inline const std::string& ShipState_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ShipState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ShipState_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ShipState_descriptor(), enum_t_value
        );
    }
    inline bool ShipState_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShipState* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShipState>(
            ShipState_descriptor(), name, value
        );
    }
    enum BuildingType : int
    {
        NULL_BUILDING_TYPE = 0,
        FACTORY = 1,
        COMMUNITY = 2,
        FORTRESS = 3,
        WORMHOLE = 4,
        BuildingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        BuildingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool BuildingType_IsValid(int value);
    constexpr BuildingType BuildingType_MIN = NULL_BUILDING_TYPE;
    constexpr BuildingType BuildingType_MAX = WORMHOLE;
    constexpr int BuildingType_ARRAYSIZE = BuildingType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BuildingType_descriptor();
    template<typename T>
    inline const std::string& BuildingType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, BuildingType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function BuildingType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            BuildingType_descriptor(), enum_t_value
        );
    }
    inline bool BuildingType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuildingType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BuildingType>(
            BuildingType_descriptor(), name, value
        );
    }
    enum ShipType : int
    {
        NULL_SHIP_TYPE = 0,
        CIVILIAN_SHIP = 1,
        MILITARY_SHIP = 2,
        FLAG_SHIP = 3,
        ShipType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        ShipType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool ShipType_IsValid(int value);
    constexpr ShipType ShipType_MIN = NULL_SHIP_TYPE;
    constexpr ShipType ShipType_MAX = FLAG_SHIP;
    constexpr int ShipType_ARRAYSIZE = ShipType_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShipType_descriptor();
    template<typename T>
    inline const std::string& ShipType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ShipType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ShipType_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            ShipType_descriptor(), enum_t_value
        );
    }
    inline bool ShipType_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShipType* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShipType>(
            ShipType_descriptor(), name, value
        );
    }
    enum PlayerTeam : int
    {
        NULL_TEAM = 0,
        UP = 1,
        DOWN = 2,
        PlayerTeam_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        PlayerTeam_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool PlayerTeam_IsValid(int value);
    constexpr PlayerTeam PlayerTeam_MIN = NULL_TEAM;
    constexpr PlayerTeam PlayerTeam_MAX = DOWN;
    constexpr int PlayerTeam_ARRAYSIZE = PlayerTeam_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerTeam_descriptor();
    template<typename T>
    inline const std::string& PlayerTeam_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PlayerTeam>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PlayerTeam_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            PlayerTeam_descriptor(), enum_t_value
        );
    }
    inline bool PlayerTeam_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerTeam* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerTeam>(
            PlayerTeam_descriptor(), name, value
        );
    }
    enum GameState : int
    {
        NULL_GAME_STATE = 0,
        GAME_START = 1,
        GAME_RUNNING = 2,
        GAME_END = 3,
        GameState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
        GameState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
    };
    bool GameState_IsValid(int value);
    constexpr GameState GameState_MIN = NULL_GAME_STATE;
    constexpr GameState GameState_MAX = GAME_END;
    constexpr int GameState_ARRAYSIZE = GameState_MAX + 1;

    const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameState_descriptor();
    template<typename T>
    inline const std::string& GameState_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, GameState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function GameState_Name.");
        return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
            GameState_descriptor(), enum_t_value
        );
    }
    inline bool GameState_Parse(
        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameState* value
    )
    {
        return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameState>(
            GameState_descriptor(), name, value
        );
    }
    // ===================================================================

    // ===================================================================

    // ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

    // @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

PROTOBUF_NAMESPACE_OPEN

template<>
struct is_proto_enum<::protobuf::PlaceType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::PlaceType>()
{
    return ::protobuf::PlaceType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::CollectorType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::CollectorType>()
{
    return ::protobuf::CollectorType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::ArmorType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::ArmorType>()
{
    return ::protobuf::ArmorType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::ShieldType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::ShieldType>()
{
    return ::protobuf::ShieldType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::BuilderType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::BuilderType>()
{
    return ::protobuf::BuilderType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::BulletType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::BulletType>()
{
    return ::protobuf::BulletType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::ShipState> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::ShipState>()
{
    return ::protobuf::ShipState_descriptor();
}
template<>
struct is_proto_enum<::protobuf::BuildingType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::BuildingType>()
{
    return ::protobuf::BuildingType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::ShipType> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::ShipType>()
{
    return ::protobuf::ShipType_descriptor();
}
template<>
struct is_proto_enum<::protobuf::PlayerTeam> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::PlayerTeam>()
{
    return ::protobuf::PlayerTeam_descriptor();
}
template<>
struct is_proto_enum<::protobuf::GameState> : ::std::true_type
{
};
template<>
inline const EnumDescriptor* GetEnumDescriptor<::protobuf::GameState>()
{
    return ::protobuf::GameState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
